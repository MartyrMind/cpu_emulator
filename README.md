## Эмулятор процессора (двухадресная архитектура)

Этот проект — учебный эмулятор CPU с фон-неймановской архитектурой и двухадресными командами (DEST = DEST op SOURCE), 32-битной разрядностью, 8 регистрами общего назначения и стеком. Есть:
- ядро (ALU, память, регистры, флаги, декодер, CPU),
- простой ассемблер и загрузчик программ,
- консольные демонстрации,
- графический интерфейс на Tkinter с пошаговой отладкой, просмотром памяти и исходного текста.

### Быстрый старт

- Консольные демо:
  - Запуск: `python -m cpu_emulator.main`
  - Демонстрации: суммирование массива, свёртка массивов, длинная арифметика

- GUI (Tkinter):
  - Запуск: `python -m cpu_emulator.main --gui`
  - Возможности: загрузка ASM из файла, кнопки-сценарии (загружают пример), Step/Run/Pause/Reset, просмотр регистров/флагов/PC/IR, память (Bytes/Words), подсветка текущей инструкции, исходник справа.

- VS Code (Debug):
  - Консоль: конфигурация «CPU Emulator: Console Demos»
  - GUI: конфигурация «CPU Emulator: GUI»

### Структура проекта

```
cpu_emulator/
  cpu_emulator/
    core/
      alu.py              # АЛУ: арифметика, логика, сдвиги, флаги
      cpu.py              # Цикл Fetch–Decode–Execute, исполнение опкодов
      decoder.py          # Кодирование/декодирование 32-битной команды
      flags.py            # Флаги Z,S,C,O,P и логика их обновления
      instruction_set.py  # OpCode, типы команд, структура Instruction
      memory.py           # Память: байты/слова, выравнивание, проверки адресов
      program_loader.py   # Простой ассемблер и утилиты загрузки
      registers.py        # Регистры: GPR[0..7], PC, IR, SP (как R8)
    gui.py               # Tkinter GUI: загрузка, шаг/запуск, память, исходник
  main.py                # Точка входа (демо/GUI)
  tests/                 # Юнит-тесты для core
  .vscode/launch.json    # Конфигурации запуска
```

Минимальный путь погружения:
1) Посмотрите `core/instruction_set.py` — набор опкодов и формат команд.
2) Загляните в `core/decoder.py` — как 32 бита превращаются в структуру `Instruction` и обратно.
3) Откройте `core/alu.py` и `core/flags.py` — семантика операций и обновление флагов.
4) Пройдитесь по `core/cpu.py` — Fetch–Decode–Execute, вызовы ALU и память.
5) Для практики откройте GUI (`--gui`) и «прошагаете» программу, наблюдая регистры/память.

### Архитектура и модель

- 32-битные регистры: R0–R7; `SP` доступен как `R8` (в стиле RISC-V), есть `PC` (program counter) и `IR` (последняя загруженная 32-битная команда)
- Память: по умолчанию 256 KiB, выровненные 32-битные слова (адрес кратен 4)
- Инструкции: 32 бита: `opcode(8) | reg1(8) | operand(16)`
  - Типы: `NO_OPERANDS`, `REG_REG`, `REG_IMM`, `REG_UNARY`, `LOAD`, `STORE`, `JUMP`, `FLAG_OP`
- Двухадресная семантика: результат записывается в первый операнд (`DEST`)

### Ассемблер (упрощённый)

Поддерживаются базовые мнемоники (регистр `R0..R8`, где `R8` — `SP`), константы `#N` или `#0xHEX`, переходы по абсолютному адресу (в байтах).

Примеры:
```
MOV R0, #100
MOV R1, #200
ADD R0, R1
STORE [R8], R0    ; через стек (SP)
LOAD R2, [R8]
JNZ 72            ; переход к адресу 72 (байты от начала программы)
HALT
```

Стек в стиле RISC‑V реализуется базовыми инструкциями:
- PUSH R1 ≡ `SUB R8, #4` → `STORE [R8], R1`
- POP R1  ≡ `LOAD R1, [R8]` → `ADD R8, #4`

Сборка и загрузка:
- В консоли: используйте `ProgramLoader.assemble_simple(lines)` → `CPU.load_program(bytes)`
- В GUI: кнопка «Load ASM…», затем Step/Run

### GUI: как пользоваться

- Управление:
  - Load ASM… — загрузка файла с мнемониками
  - Reset, Step, Run, Pause — управление выполнением
  - Hz — частота при Run
  - Сценарии — «Сумма массива», «Свертка массивов» (загружают пример, запуск вручную)
  - View: Bytes/Words, Rows: N, Goto PC, Follow PC

- Окна:
  - Registers/Flags/PC/IR/Cycles — текущее состояние
  - Memory —
    - Bytes: 16 байт/строка (hex + ASCII), подсветка строки с `PC`
    - Words: 1 слово/строка (адрес + hex, выравнивание по 4), подсветка слова `PC`
  - Program (ASM) — исходные строки с адресами, подсветка строки по `PC`

### Консольные демонстрации

Смотрите `main.py`: три примера — сумма массива, свёртка, длинная арифметика (64‑бит через пары регистров + флаг переноса).

### Расширение/изменения

- Добавить новые опкоды: допишите `OpCode` и `INSTRUCTION_FORMATS` в `instruction_set.py`, реализуйте логику в `cpu.py` (и при необходимости в `alu.py`).
- Новые режимы адресации/форматы команд — расширьте `Instruction`, `InstructionDecoder.encode/decode`.
- Дополнительные виды памяти/размеры — меняйте `Memory` и параметры CPU.
- GUI — легко расширить: редактирование памяти, изменение регистров, брейкпоинты.

### Тесты

`pytest -q` — базовые тесты для памяти, регистров, флагов, ALU.

### Требования

- Python 3.13+
- Зависимости в `pyproject.toml` (loguru, pytest, ruff, mypy)

---